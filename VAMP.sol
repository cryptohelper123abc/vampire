// SPDX-License-Identifier: MIT
//   #(#.       ,,,%,,,,,,,.##,,,,,,,,,,,,/%#%,,,,,,,,,,,.%%#%,,,,,,%%#%#%##%#.,,,,/##,,,,,,*%#%#%#%#%*,,,,,,,,*#%#%##%%))#
//   ,##((      ,/#(.,,,,,*(*%#(*.,,,,,,,,/(*%#*.,,,,,,.,#.##%.,,,.(#%*,,,,.%#%.,,.*%%/.,,, .%%,,,,,.(##(,,,,,,*##*
//    .##%     ..#.,,,,,. #,,,%%/,,,,,,,,,.#.*%%/..,,,,,%.(###.,,,,.%%,,,,,/###,,,,*#%..,,,,,##,.,,..###.,,,,,.##%*    
//      (##/   #%.,,,,,.##.,,,(##/,,,,,,,..#.,.%%/(,,./#.,.%%*,,,,,.%%.,.*#%#.,,,,,*#%.,,,,,.%#*.(#%(/,.,,,,,,,*%###((((%#
//      ./%%, .%.,,,,,,.%%%%####%#(.,,,,,.##.,,.%#%.,((.,.*##*,,,,..%#(.,,,,,,,,,,,*#%.,,,,,,#%,..(%#(.,,,,,,,,,##*   
//        /#%*#.,,,,,.,#.,,,,,,,.###*,,,,,.#,,,.,####(.,,,.%##.,,,,(##.,,,,,,,,,,,.###(,,,,,/##/,,,.(##/.,,,,,,/%##   
//         ,%%.,,,,,.##.. . ..,,,*###.,,,,,%**,,,.(%,,,,,,,##/,,,,,,##*,,,,,,,,,,,,/#%,,,,,,,##/,,,,.*###*..,,,/#####(((#%(
//           @   */////////*////((//(//((((((((####((##############(#(((((####/,/#########**.,.. .######(  .##,
//              *///////////((((((##(####(##################%#%############################(*####,   ..#    ###*
//             .//*/////////(####(#####%###########################################/(##(####.(. ....*###(# #,###(.
//             .//////////*/((#/#(##########################%###########%#########......./###(.. /#  (##  ,(##       .*
//            .////////,,,,,,,,,*****/*/(####%#%#%###############%##%##########//,..,...,,,.*##((((# .###((      ..
//            ./////**.... ....... ,....,.,******//(##(########(//(*(/#(#...   ,,/..........##### ,#*/# .       .  .#.(
//           .*/////////,*.                .    ...*,,,**#####/,,,.   ##*. *@@@(@@@@@.. .../#####(* .#  /    . ######.#
//           .//////////////..,&@@@@@@#&@@&%@.       ,*(#####(/,.    /#, @@@@@@@@@@@@,.##(######/.  #####.#(########.
//           .////////(((#///,,((#&&@@@&&@@@(,,./(//*/(###%&##(/,,#####     .,&( .,...(#./,.##/##############.##,
//           .//////((#######//**,*.*.*/**///######%#(##%%&&%##/*/((##.. .,.,/((/((..#...*###################    ..
//            .*////#(##########(//*(////((#######(#######&&###/*/(((#(##( .*####(*#,(.,*(,#################       ...
//             .*///(################################(####&@%##/*((#(#########,.*. ...,..#############              ...
//             ../////(###################################%@##(///(##################/#############.*/#.             .
//               .*/////##################################&&##///((##*  ###########*###############, #,.        ..
//                .,/////(################################&&%#(/((####*...###########################,         .      .
//               . ..*///(/##############################%&&%##((#########./#########*###############,     .
//                 ...*//////(#########%########/(#((#####%%############(####################.#######                 .
//                  ...///////((###############//(#######%#################/# *############,########             ..
//                    .,//////((#(##############//(/######&@&#(########.(#/ ##..#########(######/     *, .,**///*    ..
//                     .*///////###############/**,*/#####%%#####/#( ./#  ./*//. #############/..           ./////*////
//                      ../////((##############( .   .**###(###    .  .     ,,#.(.##########*                   *,,/**.
//                       ..*//////(##(%##########(((*.  ,,,#(#           .   . .*######### .////                  *,* ,
//                        ..*///////(#####//#/(/***/,,,,  .##                  . #######***.  *//               .,. *..
//                          .,///////*,*,*,,,*,,,,,, .(#((##        .        .    . .,****,*,*////**          */,,. *//
//                           .////*,. ......,.,., ..,.(####.     ...,. .@@   ....   .   ,*////////*           ,**,,.*,.
//                            .*/,..              . ...##(   .   &&.*@@@@     . .        **////////*///**  .   ,   ..
//                              .,.                   .##. #@#@*@@&,@@@@*      ...  ,//*///*,//./*./////***    *,
//                              . .    ..**//*/,.......##  &@@@ @@@ @@@@        /// ..///////////////  */*.,.**/
//                                     *//////////(**/##    @@   @  &@@...    ,/*,,//*///////***///*/// ,/   /*,
//                                    .,,/////////////#(             @ ..,   ,//*, .///*.. . ,,,*//////.    ,,
//                                   ....*////*....#/##                @@.   ////*,**/*///**,,,///,.,,,,.
//                                     ...*////,**(###.               %@@@  /////,./*/,////*////.  .,**  *
//                                        ..*/////### .             @%#/.  ./////,.***//*////*,**. ***        `       .
//                                         ...,/(####.  .          .#@/*(  //////*/////////****
//                                           .((####(  ..        %@#@#&,,,*//////////////**/..              `     `
//                                           ... ###          .  %((/%&**////,.../*,.., **,,, .              `      `
//                                     . ......####     .     ..@&#&/* , **//.//*,       ,**.  */.  *.
//                                   **(########### %#  #*.@  &%%%/....*///*,**       . ..  .,******/.      `       `
//        .            ..       ...     . #/###########%(##@# ,&.  */*///*,,,           .****,,.    /                 .
//         ..                       ... ..  ,*#######*(.#..#.     ,//*. ,.*/.        ..*.                .,,,,,***,,,.
//                                      .  , ..####          ..   ***,,,,,         .               .**,        .
//                                .   .    . .,,./,.     .   . .**//,*, ,      .,.         .**... ,  .       ..
//                                      ..   *.  . .(.    ....*,**., */*.  ,*,          .*.
//                  .   .           .   ......      .   .  . .*/**////.,*/*//,  ..,****.
//                ...            ..  ...... .      ..,....      ..,   ...   .*//*,.  ,..        ..


/*




Vampire (VAMP) is a deflationary fair launched token designed to have big buybacks and burns by incorporating a Jackpot system.

Website: https://vampire.biz
Twitter: https://twitter.com/VampToken
Telegram: https://t.me/VampireToken
Discord: https://discord.gg/ANAqkm5xrk

Whitepaper: https://vampire.biz/whitepaper
Bloodpaper: https://vampire.biz/bloodpaper
Team: https://vampire.biz/team
Audits: https://vampire.biz/audits



====================EXECUTIVE SUMMARY===============
When someone buys $10 of VAMP they become the last buyer stored in the smart contract code.
If there are no new buyers for 10 minutes, then the last buyer wins half the FTM Jackpot stored inside the smart contract.
The other half of the FTM Jackpot is used to buyback and burn VAMP. A small portion is used to pay the team for marketing and development.
If someone makes a new purchase then they become the new last buyer and the 10 minute timer is reset.
This means there is no way to rig a buy so that the last buyer can be the winner of the Jackpot, without waiting 10 minutes.

The Jackpot has a hardlimit of $100,000.
When the Jackpot reaches $100,000 Morbin Time is released.
Morbin Time will use $70,000 to perform a massive buyback and burn.
$30,000 will be left to restart the Jackpot so that there is always a Jackpot to be won, and pay the team for marketing and development costs.

New buyers are incentivized because there is always a Jackpot to be won.

Sellers are discouraged because of the 8% sell tax, which sucks the FTM into the Jackpot.

The Jackpot and Morbin Time bring up the price floor as VAMP is bought back and burned.

VAMP is a true deflationary token, there is no yield generation or way to gain back the VAMP that has been burned.

It's the only project on FTM that literally sucks!



====================GOOD TOKENOMICS================
VAMP's total supply is 1,000,000 (1 Million) and the breakdown is the following:

4% - 40,000 VAMP - Marketing, Locked for 90 days in the VAMP Coffin Locker Contract
1% - 10,000 VAMP - Dev Team, Locked for 90 days in the VAMP Coffin Locker Contract
5% - 50,000 VAMP - CEX Liquidity, Locked for 180 days in the VAMP Coffin Locker Contract
40% - 400,000 VAMP - Liquidity Fair Launched on SpookySwap
50% - 500,000 VAMP - Burned Right Before Fair Launch



======================LOW TAXES====================
To fund the Jackpot and Morbin Time, low taxes are performed on each buy, sell, and trasfer.
2% on each Transfer.
3% on each Buy.
8% on each Sell.

Jackpot Tax Breakdown:
1% on Transfers.
2% on Buys.
5% on Sells.

Marketing Tax Breakdown:
1% on Transfers.
1% on Buys.
2% on Sells.



======================LIQUIDITY=====================
Starting Liquidity of VAMP/FTM is 400,000 VAMP paired with $5,000 of FTM
This results in a starting marketcap of $5,000 and a price of $0.0125 per VAMP
This Liquidity is locked for 180 days in the VAMP Coffin Locker Contract



======================ROADMAP=======================
July 1st - Website, Social Media, and Communities are launched.
July 8th - VAMPIRE BLOOD DRIP - NFTs are given to anyone who would like one.
July 15th - Liquidity Fair Launched
July 16th - VAMP is listed on several token trackers such as CoinGecko, CoinMarketCap, etc.
July 22nd - Contact established with SpookySwap, Tomb, Fantom Foundation, and other Fantom Eco System Projects
July 29th - Deploy any new projects and pools with any partnered projects.
August 19th - Deploy a welding business website to promote real world ventures.
September 2nd - Build a BLOOD BOOK system that allows a centralized exchange style order book, but using a decentralized smart contract.
All dates are tentative.



===============VAMPIRE BLOOD DRIP NFTS===============
10,000 Vampire NFTs were minted to be given as a Blood Drip.
These were created with PaintSwap and are able to be traded, sold, and purchased.
To get your free NFT visit discord, telegram, or twitter and request one.



=================NO VENTURE CAPITALISTS=============
VAMP does not have Venture Capitalist funding.
VAMP did not have a presale.
VAMP did not have a private sale.
Vampire's funding comes directly from the team.



==================INVESTOR PROTECTION===============
VAMP stops bot contracts from participating in the Jackpot. 
Contracts can still interact with the contract to buy, sell, and transfer normally, but they will not be counted as the Last Buyer.
This safeguards the Jackpot mechanism from rigging buys so that the Jackpot would never fire.



===================MAX WALLET SIZE==================
Each wallet can only have a maximum of 50,000 VAMP (5% of the total supply).
This helps curb Whales from buying and controlling the supply.



===================DAO PARTNERSHIP==================
VAMP seeks to become partnered with existing DAOs to further expand the Fantom Ecosystem.
VAMP does not intend to become its own DAO.



=======================AUDITS=======================
Audits are in queue and will be updated on Vampire's website and announce on social media.



===================CEX LISTINGS=====================
VAMP is reaching out to the following CEXs:
KuCoin
Gate.io
Hotbit
MEXC
BKEX
BitMart
XT.COM
CoinEx
and of course.... Binance



======================TEAM==========================
JaWohlDev - Graphic Designer and Scripting Developer for Morbin Time and Jackpot Announcements
Triss - Web Developer and Frontend Engineer
Henry Case - Smart Contract Developer
Giacomo - Marketer and Community Management
Bonham - NFT AI Developer and Meme Maker
Contact us through Discord, Telegram, Twitter, or send an email to team@vampire.biz



==================JACKPOT EXAMPLE====================
This example uses rough estimates. 
Prices are not intended to be exact.
This is not intended to be a model of how Liquidity Pools work. 
Price impacts are removed to illustrate the use case.

Starting Scenario:
Pool: 10000 VAMP / 1000 FTM
Price: 1 VAMP = 0.1 FTM
Jackpot: 0 FTM

Buyer uses 100 FTM to buy 1000 VAMP
10% of the VAMP (100 VAMP) is taken and sold back for 10 FTM.
This FTM is moved into the Jackpot.

Pool: 9100 VAMP / 1090 FTM
Price: 1 VAMP = 0.12 FTM
Jackpot Amount: 10 FTM

Buyer uses 100 FTM to buy 1000 VAMP
This time it would take a little bit more FTM to buy 100 VAMP as the price has increased, 
but we will round it down to make the price "fit" for the example.

Pool: 8200 VAMP / 1180 FTM
Price: 1 VAMP = 0.14 FTM
Jackpot Amount: 20 FTM

Jackpot activates because the Buyer 
was the Last Buyer for 10 minutes.
Winner is awarded 50% of the FTM Jackpot = 10 FTM
30% of the FTM Jackpot is used to buyback and burn = 6 FTM
6 FTM is swapped to buy 43 VAMP for 0.14 FTM per VAMP

Ending Pool
Pool: 8157 VAMP / 1186 FTM
Price: 1 VAMP = 0.15 FTM
Jackpot: 3 FTM (Leftover to Restart)

The 43 VAMP is burned completely out of the system never to be used again.

Morbin Time uses 70% to buyback and burn, leaving 20% for the next Jackpot.

The VAMP Team takes a small portion of the Jackpot FTM 
each time the Jackpot and Morbin Time Activates.



=================PRICE PROJECTION===============
This is not financial advice nor is this chart intended to help make you financial decisions.
Talk to your financial advisor not your telegram alpha group or your mongolian basketweaving forum.
*/
//............................................................................................................................................................................     
//                  Vampire (VAMP) Price Projections        -       Price Floor Raised Each Jackpot and Morbin Time Because of the Buyback and Burn                                                                                                                                        
//                                                                                                                                                               $$
//                                                                                                                                                              //   
//                                                                                                                                                             //
//                                                                                                                                               $$           //   
//                                                                                                                                              //\\         //    
//                                                                                                                                             //  \\       //     
//                                                                                                                 Morbin Time                //    \\     //    
//                                                                                                                                           //      \\   //      
//   Price Floor 3 .........................................................................................................................//........\\_//....Price Floor Raised Each Jackpot and Morbin Time  
//                                                                                                                                         //    
//                                                                                                                                        //       
//                                                                                                                                       //           
//                                                                                                                                      //            
//                                                                                                                      $$             //               
//                                                                                                                     //\\           //                  
//                                                                                                                    //  \\         //                    
//                                                                                                                   //    \\       //                     
//                                                                                               2nd Jackpot        //      \\     //                     
//                                                                                                                 //        \\   //     
//   Price Floor 2 ...............................................................................................//..........\\_//.......Price Floor Raised Each Jackpot and Morbin Time           
//                                                                                                               //                             
//                                                                                                              //                                
//                                                                                                             //                                 
//                                                 $$$                               $$                       $$                                  
//                                                ////                             . //                       ||                                   
//                                              /,,/* /.                         / /   \\            $$       ||                                    
//                                            ,///    ./,                      /        \\           //\\    ||                                      
//                                           //        .//                //  /          \\         //  \\  //                                        
//                   First Jackpot         //          *  //        /  / /                \\       //    \\//                                         
//                                        //             / ,/      / //                    \\     //                                              
//   Price Flooor 1 .....................//................/.././///........................\\___//..............Price Floor Raised Each Jackpot and Morbin Time
//                                     ///                                                                                     
//                                   /,/                                                                                  
//                                  /,/                                                                                            
//                                 /,/                                                                                             
//                                /,/                                                                                                               
//                               /,/                                                                                  
//                             ///                                                                                                                   
//                            /,/                                                                                                                          
//                        //////                                                                                                                                   
//                    ////                                                                                                                                      
//             //////                                                                                                                                      
//    //////////                                                                                                                                                                                        
//............................................................................................................................................................................    
//           LAUNCH                Week 1                Week 2                 Week 3               Month 1                          Month 2



pragma solidity ^0.8.15;



// Imports From OpenZeppelin - Updated Solidity Version
// Interfaces
import "../interfaces/IERC20.sol";
import "../interfaces/IERC20Metadata.sol";
// SpookySwap Interfaces
import "../interfaces/IUniswapV2Router02.sol";
import "../interfaces/IUniswapV2Factory.sol";
// Libraries
import "../libraries/SafeMath.sol";
// Utilities
import "../utils/Context.sol";
import "../utils/Ownable.sol";



contract VAMP is Context, IERC20, IERC20Metadata, Ownable {

    using SafeMath for uint256;

    // Events
    event DevWalletChanged(address indexed previousDevWallet, address indexed newDevWallet);
    event MarketingWalletChanged(address indexed previousMarketingWallet, address indexed newMarketingWallet);

    // Tax Changed Events
    event JackpotTaxOnTransfersChanged(uint256 oldJackpotTaxOnTransfers, uint256 newTaxAmount);
    event MarketingTaxOnTransfersChanged(uint256 oldJackpotTaxOnTransfers, uint256 newTaxAmount);
    event DevTaxOnTransfersChanged(uint256 oldJackpotTaxOnTransfers, uint256 newTaxAmount);
    event JackpotTaxOnBuysChanged(uint256 oldJackpotTaxOnTransfers, uint256 newTaxAmount);
    event MarketingTaxOnBuysChanged(uint256 oldJackpotTaxOnTransfers, uint256 newTaxAmount);
    event DevTaxOnBuysChanged(uint256 oldJackpotTaxOnTransfers, uint256 newTaxAmount);
    event JackpotTaxOnSellsChanged(uint256 oldJackpotTaxOnTransfers, uint256 newTaxAmount);
    event MarketingTaxOnSellsChanged(uint256 oldJackpotTaxOnTransfers, uint256 newTaxAmount);
    event DevTaxOnSellsChanged(uint256 oldJackpotTaxOnTransfers, uint256 newTaxAmount);

    // Fee Events
    event AddressIncludedOrExcludedInFee(address indexed account, bool isExcluded);

    // Max Wallet Events
    event AddressIncludedOrExcludedInMaxWalletSize(address indexed account, bool isExcluded);
    event MaxWalletSizeChanged(uint256 oldMaxWalletSize, uint256 newMaxWalletSize);

    // SpookySwap Events
    event SpookySwapRouterChanged(address indexed newRouterAddress);
    event SpookySwapPairChanged(address indexed oldPairAddress, address indexed newPairAddress);
    event AddressAllowedOrNotToProvideLiquidity(address indexed account, bool isAllowed);

    // Dollar Peg for FTM Events
    event DollarPegChangedToUsdc(address indexed usdcAddessChangedTo);
    event DollarPegChangedToDai(address indexed daiAddessChangedTo);

    // Trading Events
    event TradingOpened(bool isTradingNowOpen);
    event BoughtVAMP(address indexed buyerAddress, uint256 vampBoughtAmount, uint256 timeOfBuy);
    event SoldVAMP(address indexed sellerAddress, uint256 vampSoldAmount, uint256 timeOfSell);
    
    // Morbin Time Events
    event MorbinTimeEnabled(bool MorbinTimeIsEnabled);
    event MorbinTimeDisabled(bool MorbinTimeIsDisabled);
    event MorbinTimeAmountChanged(uint256 oldMorbinTimeAmount, uint256 newMorbinTimeAmount);
    event MorbinTimeMarketingPercentChanged(uint256 oldMorbinTimeMarketingPercent, uint256 newMorbinTimeMarketingPercent);
    event MorbinTimeDevPercentChanged(uint256 oldMorbinTimeDevPercent, uint256 newMorbinTimeDevPercent);
    event MorbinTimeBuybackPercentChanged(uint256 oldMorbinTimeDevPercent, uint256 newMorbinTimeDevPercent);
    event ItsMorbinTime(uint256 amountOfFtmUsedToBuyBackAndBurn, uint256 totalMorbinTimes,uint256 totalMorbinTimeFtmUsedToBuyBackAndBurn,
                        uint256 jackpotBalanceInFtm, uint256 jackpotBalanceInDollarValue, uint256 timeOfMorbinTime);
    event BuyBackForMorbinTime(uint256 amountOfVampThatWasBurned, uint256 totalMorbinTimeVampAmountBoughtBackAndBurned, uint256 timeOfBuyBack); 
                        
    // Jackpot Events
    event JackpotEnabled(bool JackpotIsEnabled);
    event JackpotDisabled(bool JackpotIsDisabled);
    event JackpotFunded(uint256 ftmAddedToJackPot, uint256 timeOfJackpotFunded);
    event JackpotTimeToOccurAfterLastBuyChanged(uint256 oldTimeForJackpotToOccurAfterLastBuy, uint256 newTimeForJackpotToOccurAfterLastBuy);
    event JackpotMinAmountChanged(uint256 oldJackpotMinAmount, uint256 newJackpotMinAmount);
    event JackpotMarketingPercentChanged(uint256 oldMarketingJackpotPercent, uint256 newMarketingJackpotPercent);
    event JackpotDevPercentChanged(uint256 oldDevJackpotPercent, uint256 newDevJackpotPercent);
    event JackpotBuybackPercentChanged(uint256 oldBuybackJackpotPercent, uint256 newBuybackJackpotPercent);
    event JackpotAwarded(address jackpotWinner, uint256 amountFtmAwardedToWinner, uint256 amountOfFtmUsedToBuyBackAndBurn, uint256 totalJackpotTimes, uint256 totalJackpotFtmAmountAwarded, 
                        uint256 totalJackpotDollaValueAwarded, uint256 totalJackpotFtmAmountBoughtBackAndBurned, uint256 jackpotBalanceInFtm, uint256 jackpotBalanceInDollarValue, uint256 timeOfJackpotAward);
    event BuyBackForJackpot(uint256 amountOfVampThatWasBurned, uint256 totalJackpotVampAmountBoughtBackAndBurned, uint256 timeOfBuyBack); 
    event JackpotTimeExtended(address lastBuyer, uint256 lastBuyTimestamp, uint256 jackpotFundAmountInFtmAmount, uint256 jackpotFundAmountInDollarValue, uint256 newTimeForJackpotToOccur);
    
    // Swap Events
    event SwappedFtmForVamp(uint256 ftmAmount, uint256 vampAmountBurned);       
    event SwappedVampForFtm(uint256 vampAmount, uint256 ftmAmount);




    
    

    // Standard ERC-20 Variables
    string private constant _name = "Vampire";
    string private constant _symbol = "VAMP";
    mapping(address => uint256) private _balances;
    mapping(address => mapping(address => uint256)) private _allowances;
    uint8 private constant _decimals = 18;
    uint256 private constant _totalSupply = 10**6 * (10**_decimals);    // 1 Million VAMP


    // SpookySwap Variables
    address public spookySwapRouterAddress = 0xF491e7B69E4244ad4002BC14e878a34207E38c29;  
    IUniswapV2Router02 public spookySwapRouter;
    address public spookySwapPairAddress;
    mapping(address => bool) public isAllowedToProvideLiquidity;


    // Vampire Variables

    // Wallet Variables
    address public marketingWallet = 0x722C0b5dc4eDFBAb2d022C3B5c16d95EE7e7D254;
    address public devWallet = _msgSender();

    // Token Variables
    uint256 public constant usdcDecimals = 6;
    address public constant usdcAddress = 0x04068DA6C83AFCFA0e13ba15A6696662335D5B75;
    address public constant daiAddress = 0x8D11eC38a3EB5E956B052f67Da8Bdc9bef8Abf3E;
    address public dollarPegAddress = usdcAddress;      // can be changed to daiAddress using the change peg function

    // Max Wallet Variables
    uint256 public maxWalletSize = _totalSupply.mul(5).div(100);    // 5%, 50 Thousand
    mapping(address => bool) public isExcludedFromMaxWalletSize;


    // Morbin Time Variables
    bool public isMorbinTimeEnabled = true;

    uint256 public morbinTimeAmount = 10**4 * 10**_decimals;   // $10,000 

    uint256 public constant morbinTimeAmountMax = 10**6 * 10**_decimals;   // max is $1,000,000  
    uint256 public constant morbinTimeAmountMin = 10**4 * 10**_decimals;   // min is $10,000  
    // Morbin Time Percent Variables
    uint256 public marketingMorbinTimePercent = 9;
    uint256 public constant marketingMorbinTimePercentMax = 9;
    uint256 public devMorbinTimePercent = 1;
    uint256 public constant devMorbinTimePercentMax = 1;
    uint256 public buybackMorbinTimePercent = 70;
    uint256 public constant buybackMorbinTimePercentMax = 70;
    uint256 public constant buybackMorbinTimePercentMin = 50;
    // Morbin Time Tracker Variables
    uint256 public totalMorbinTimes = 0;
    uint256 public totalMorbinTimeVampAmountBoughtBackAndBurned = 0;
    uint256 public totalMorbinTimeFtmAmountBoughtBackAndBurned = 0;
    uint256 public lastTimeMorbinTimeOccured = 0;
    




    // Jackpot Variables
    bool public isJackpotEnabled = true;

    uint256 public jackpotMinAmount = 10**3 * 10**_decimals;   // $1,000 

    uint256 public constant jackpotMinAmountMax = 10**4 * 10**_decimals;   // max is $10,000
    uint256 public constant jackpotMinAmountMin = 10**2 * 10**_decimals;   // min is $100
    // Jackpot Percent Variables
    uint256 public constant winnerJackpotPercent = 50;
    uint256 public marketingJackpotPercent = 9;
    uint256 public constant marketingJackpotPercentMax = 9;
    uint256 public devJackpotPercent = 1;
    uint256 public constant devJackpotPercentMax = 1;
    uint256 public buybackJackpotPercent = 10;
    uint256 public constant buybackJackpotPercentMax = 30;
    uint256 public constant buybackJackpotPercentMin = 10;
    // Jackpot Last Buyer Variables
    address public lastBuyer = 0x000000000000000000000000000000000000dEaD;
    uint256 public lastBuyTimestamp = 0;
    uint256 public timeForJackpotToOccurAfterLastBuy = 10 minutes;
    uint256 public constant timeForJackpotToOccurAfterLastBuyMax = 30 minutes;
    uint256 public constant timeForJackpotToOccurAfterLastBuyMin = 5 minutes;
    uint256 public timeForJackpotToOccur = 0;


    // Jackpot Min Buy Variables
    uint256 public minBuyAmountForJackpotLastBuy = 10 * 10**_decimals;   // $10 

    uint256 public constant minBuyAmountForJackpotLastBuyMax = 50 * 10**_decimals;   // max is $50
    uint256 public constant minBuyAmountForJackpotLastBuyMin = 10**_decimals;   // min is $1

    bool public isBuyBackForJackpot = true;


    // Jackpot Tracker Variables
    uint256 public totalJackpotTimes = 0;
    uint256 public totalJackpotVampAmountBoughtBackAndBurned = 0;
    uint256 public totalJackpotFtmAmountBoughtBackAndBurned = 0;
    uint256 public totalJackpotAmountAwarded = 0;
    uint256 public lastTimeJackpotOccured = 0;
    uint256 public lastJackpotAmountAwarded = 0;
    address public lastJackpotWinner = 0x000000000000000000000000000000000000dEaD;


    // Morbin Time and Jackpot Variables
    bool public isMorbinOrJackpotin = false;      // Reentrancy Checks
    uint256 public amountToBuybackAndBurnForJackpotOrMorbinTime = 0;
    bool public isTimeToProcessBuyBack = false;
    

    // Tax Variables
    mapping(address => bool) public isExcludedFromFee;
    // Transfer Tax Variables
    uint256 public jackpotTaxOnTransfersPercent = 1;     // 1%
    uint256 public marketingTaxOnTransfersPercent = 1;   // 1%
    uint256 public devTaxOnTransfersPercent = 0;         // 0%
    // Buy Tax Variables
    uint256 public jackpotTaxOnBuysPercent = 2;          // 2%
    uint256 public marketingTaxOnBuysPercent = 1;        // 1%
    uint256 public devTaxOnBuysPercent = 0;              // 0%
    // Sell Tax Variables  
    uint256 public jackpotTaxOnSellsPercent = 5;         // 5%
    uint256 public marketingTaxOnSellsPercent = 2;       // 2%
    uint256 public devTaxOnSellsPercent = 1;             // 1%
    // Tracker Tax Variables
    uint256 public tokensToSellForJackpot = 0;
    uint256 public tokensToSellForMarketing = 0;
    uint256 public tokensToSellForDev = 0;
    // Tax Processing
    bool public isInProcessTaxSwap = false;
    uint256 public minimumVampAmountToSwap = 10**2 * (10**_decimals);    // 100 VAMP
 

    // Misc Variables
    bool public isTradingOpen = false;      // can only set this to true, cannot turn it back to false

    
    


    
    











    // Constructor Logic

    constructor() {
        _balances[owner()] = _totalSupply;

        spookySwapRouter = IUniswapV2Router02(spookySwapRouterAddress);     
        spookySwapPairAddress = IUniswapV2Factory(spookySwapRouter.factory()).createPair(address(this),spookySwapRouter.WETH());

        // Exclude system addresses from fee
        isExcludedFromFee[owner()] = true;
        isExcludedFromFee[address(this)] = true;
        isExcludedFromFee[marketingWallet] = true;
        isExcludedFromFee[0x000000000000000000000000000000000000dEaD] = true;
        isExcludedFromFee[0xFb3a68fde218CC8D3566bc38C794faDf16e4b42f] = true;     // multisig for VAMP team

        isExcludedFromMaxWalletSize[owner()] = true;
        isExcludedFromMaxWalletSize[address(this)] = true;
        isExcludedFromMaxWalletSize[marketingWallet] = true;
        isExcludedFromMaxWalletSize[0x000000000000000000000000000000000000dEaD] = true;
        isExcludedFromMaxWalletSize[spookySwapRouterAddress] = true;
        isExcludedFromMaxWalletSize[spookySwapPairAddress] = true;
        isExcludedFromMaxWalletSize[0xFb3a68fde218CC8D3566bc38C794faDf16e4b42f] = true;     // multisig for VAMP team

        isAllowedToProvideLiquidity[owner()] = true;

        maxWalletSize = _totalSupply.div(1000);    // set to 0.1% on liquidity launch, then sets to 5% after launch

        emit Transfer(address(0), owner(), _totalSupply);
    }

    receive() external payable {}








    // Standard ERC-20 Functionality

    function name() external view virtual override returns (string memory) {
        return _name;
    }


    function symbol() external view virtual override returns (string memory) {
        return _symbol;
    }


    function decimals() public view virtual override returns (uint8) {
        return _decimals;
    }


    function totalSupply() public view virtual override returns (uint256) {
        return _totalSupply;
    }


    function balanceOf(address account) public view virtual override returns (uint256) {
        return _balances[account];
    }


    function transfer(address receiver, uint256 amount) public virtual override returns (bool) {
        address sender = _msgSender();
        _transfer(sender, receiver, amount);          
        return true;
    }


    function allowance(address owner, address spender) public view virtual override returns (uint256) {
        return _allowances[owner][spender];
    }


    function approve(address spender, uint256 amount) public virtual override returns (bool) {
        address owner = _msgSender();
        _approve(owner, spender, amount);
        return true;
    }


    function _approve(address owner, address spender, uint256 amount) internal virtual {
        require(owner != address(0), "ERC20: approve from the zero address");
        require(spender != address(0), "ERC20: approve to the zero address");

        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }


    function transferFrom(address sender, address receiver, uint256 amount) public virtual override returns (bool) {
        address spender = _msgSender();
        _spendAllowance(sender, spender, amount);
        _transfer(sender, receiver, amount);
        return true;
    }


    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {
        uint256 currentAllowance = allowance(owner, spender);
        if (currentAllowance != type(uint256).max) {
            require(currentAllowance >= amount, "ERC20: insufficient allowance");
            unchecked {
                _approve(owner, spender, currentAllowance - amount);
            }
        }
    }


    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {
        address owner = _msgSender();
        _approve(owner, spender, allowance(owner, spender) + addedValue);
        return true;
    }


    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {
        address owner = _msgSender();
        uint256 currentAllowance = allowance(owner, spender);
        require(currentAllowance >= subtractedValue, "ERC20: decreased allowance below zero");
        unchecked {
            _approve(owner, spender, currentAllowance - subtractedValue);
        }

        return true;
    }









    // Vampire Specific Functionality

    // Vampire Views / Getters

    function totalTransferTax() public view returns (uint256) {
        uint256 totalTax = jackpotTaxOnTransfersPercent.add(marketingTaxOnTransfersPercent).add(devTaxOnTransfersPercent);
        return totalTax;
    }


    function totalBuyTax() public view returns (uint256) {
        uint256 totalTax = jackpotTaxOnBuysPercent.add(marketingTaxOnBuysPercent).add(devTaxOnBuysPercent);
        return totalTax;
    }


    function totalSellTax() public view returns (uint256) {
        uint256 totalTax = jackpotTaxOnSellsPercent.add(marketingTaxOnSellsPercent).add(devTaxOnSellsPercent);
        return totalTax;
    }



    // Vampire Setters

    function excludeFromFee(address account, bool isExcluded) external onlyOwner {
        isExcludedFromFee[account] = isExcluded;
        emit AddressIncludedOrExcludedInFee(account, isExcluded);
    }


    function allowAddressToProvideLiquidity(address account, bool isAllowed) external onlyOwner {
        isAllowedToProvideLiquidity[account] = isAllowed;
        emit AddressAllowedOrNotToProvideLiquidity(account, isAllowed);
    }


    function excludeFromMaxWalletSize(address account, bool isExcluded) external onlyOwner {
        isExcludedFromMaxWalletSize[account] = isExcluded;
        if(isExcluded){
            emit AddressIncludedOrExcludedInMaxWalletSize(account, isExcluded);
        }
        else{
            require(account != spookySwapPairAddress, "Cannot be the Pair Address");
            require(account != spookySwapRouterAddress, "Cannot be the Router Address");
            require(account != 0x000000000000000000000000000000000000dEaD, "Cannot be the Dead Address");
            emit AddressIncludedOrExcludedInMaxWalletSize(account, isExcluded);
        }
        
    }


    function setMaxWalletSize(uint256 newWalletSize) external onlyOwner {
        require(newWalletSize >= _totalSupply.div(100),"Max wallet size must be at least 1% of the total supply");       // 1%, 10 Thousand
        emit MaxWalletSizeChanged(maxWalletSize, newWalletSize);
        maxWalletSize = newWalletSize;
    }

    
    function setSpookySwapRouter(address newRouterAddress) external onlyOwner {
        require(newRouterAddress != address(0), "You must supply a non-zero address");
        emit SpookySwapRouterChanged(newRouterAddress);
        spookySwapRouterAddress = newRouterAddress;
        spookySwapRouter = IUniswapV2Router02(newRouterAddress);
    }


    function setSpookySwapPair(address newPairAddress) external onlyOwner {
        require(newPairAddress != address(0), "You must supply a non-zero address");
        emit SpookySwapPairChanged(spookySwapPairAddress, newPairAddress);
        spookySwapPairAddress = newPairAddress;
    }


    function setDevWalletAddress(address newDevWallet) external onlyOwner {
        emit DevWalletChanged(devWallet, newDevWallet);
        devWallet = newDevWallet;
    }


    function setMarketingWalletAddress(address newMarketingWallet) external onlyOwner {
        emit MarketingWalletChanged(marketingWallet, newMarketingWallet);
        marketingWallet = newMarketingWallet;
    }


    function openTrading() external onlyOwner {
        emit TradingOpened(isTradingOpen);
        isTradingOpen = true;     // trading can only be enabled, never disabled
    }


    function setDollarPegToUsdc() external onlyOwner {
        emit DollarPegChangedToUsdc(usdcAddress);
        dollarPegAddress = usdcAddress;
    }


    function setDollarPegToDai() external onlyOwner {
        emit DollarPegChangedToDai(daiAddress);
        dollarPegAddress = daiAddress;
    }


    function setMinVampAmountToSwap(uint256 newAmount) external onlyOwner {
        minimumVampAmountToSwap = newAmount;
    }


    // Tax Setters
    function setJackpotTaxOnTransfers(uint256 newTaxAmount) external onlyOwner {
        emit JackpotTaxOnTransfersChanged(jackpotTaxOnTransfersPercent, newTaxAmount);
        uint256 totalTax = newTaxAmount.add(devTaxOnTransfersPercent).add(marketingTaxOnTransfersPercent);
        require(totalTax <= 5, "Tax Amount must be less than the taxLimit, which is 5%");
        jackpotTaxOnTransfersPercent = newTaxAmount;
    }


    function setMarketingTaxOnTransfers(uint256 newTaxAmount) external onlyOwner {
        emit MarketingTaxOnTransfersChanged(marketingTaxOnTransfersPercent, newTaxAmount);
        uint256 totalTax = newTaxAmount.add(devTaxOnTransfersPercent).add(jackpotTaxOnTransfersPercent);
        require(totalTax <= 5, "Tax Amount must be less than the taxLimit, which is 5%");
        marketingTaxOnTransfersPercent = newTaxAmount;
    }


    function setDevTaxOnTransfers(uint256 newTaxAmount) external onlyOwner {
        emit DevTaxOnTransfersChanged(devTaxOnTransfersPercent, newTaxAmount);
        uint256 totalTax = newTaxAmount.add(jackpotTaxOnTransfersPercent).add(marketingTaxOnTransfersPercent);
        require(totalTax <= 5, "Tax Amount must be less than the taxLimit, which is 5%");
        devTaxOnTransfersPercent = newTaxAmount;
    }


    function setJackpotTaxOnBuys(uint256 newTaxAmount) external onlyOwner {
        emit JackpotTaxOnBuysChanged(jackpotTaxOnBuysPercent, newTaxAmount);
        uint256 totalTax = newTaxAmount.add(devTaxOnBuysPercent).add(marketingTaxOnBuysPercent);
        require(totalTax <= 5, "Tax Amount must be less than the taxLimit, which is 5%");
        jackpotTaxOnBuysPercent = newTaxAmount;
    }


    function setMarketingTaxOnBuys(uint256 newTaxAmount) external onlyOwner {
        emit MarketingTaxOnBuysChanged(marketingTaxOnBuysPercent, newTaxAmount);
        uint256 totalTax = newTaxAmount.add(devTaxOnBuysPercent).add(jackpotTaxOnBuysPercent);
        require(totalTax <= 5, "Tax Amount must be less than the taxLimit, which is 5%");
        marketingTaxOnBuysPercent = newTaxAmount;
    }


    function setDevTaxOnBuys(uint256 newTaxAmount) external onlyOwner {
        emit DevTaxOnBuysChanged(devTaxOnBuysPercent, newTaxAmount);
        uint256 totalTax = newTaxAmount.add(marketingTaxOnBuysPercent).add(jackpotTaxOnBuysPercent);
        require(totalTax <= 5, "Tax Amount must be less than the taxLimit, which is 5%");
        devTaxOnBuysPercent = newTaxAmount;
    }


    function setJackpotTaxOnSells(uint256 newTaxAmount) external onlyOwner {
        emit JackpotTaxOnSellsChanged(jackpotTaxOnSellsPercent, newTaxAmount);
        uint256 totalTax = newTaxAmount.add(marketingTaxOnSellsPercent).add(devTaxOnSellsPercent);
        require(totalTax <= 10, "Tax Amount must be less than the taxLimitSellOnly, which is 10% on sells.");
        jackpotTaxOnSellsPercent = newTaxAmount;
    }


    function setMarketingTaxOnSells(uint256 newTaxAmount) external onlyOwner {
        emit MarketingTaxOnSellsChanged(marketingTaxOnSellsPercent, newTaxAmount);
        uint256 totalTax = newTaxAmount.add(devTaxOnSellsPercent).add(jackpotTaxOnSellsPercent);
        require(totalTax <= 10, "Tax Amount must be less than the taxLimitSellOnly, which is 10% on sells.");
        marketingTaxOnSellsPercent = newTaxAmount;
    }


    function setDevTaxOnSells(uint256 newTaxAmount) external onlyOwner {
        emit DevTaxOnSellsChanged(devTaxOnSellsPercent, newTaxAmount);
        uint256 totalTax = newTaxAmount.add(marketingTaxOnSellsPercent).add(jackpotTaxOnSellsPercent);
        require(totalTax <= 10, "Tax Amount must be less than the taxLimitSellOnly, which is 10% on sells.");
        devTaxOnSellsPercent = newTaxAmount;
    }


    function setMorbinTimeAmount(uint256 newMorbinTimeAmount) external onlyOwner {
        require(newMorbinTimeAmount <= morbinTimeAmountMax, "Must be less than morbinTimeAmountMax");
        require(newMorbinTimeAmount >= morbinTimeAmountMin, "Must be greater than morbinTimeAmountMin");
        emit MorbinTimeAmountChanged(morbinTimeAmount, newMorbinTimeAmount);
        morbinTimeAmount = newMorbinTimeAmount;
    }




    function setMorbinTimeMarketingAndDevPercent(uint256 newMarketingMorbinTimePercent, uint256 newDevMorbinTimePercent) external onlyOwner {
        require(newMarketingMorbinTimePercent <= marketingMorbinTimePercentMax, "Must be less than marketingMorbinTimePercentMax");
        emit MorbinTimeMarketingPercentChanged(marketingMorbinTimePercent, newMarketingMorbinTimePercent);
        marketingMorbinTimePercent = newMarketingMorbinTimePercent;

        require(newDevMorbinTimePercent <= devMorbinTimePercentMax, "Must be less than devMorbinTimePercentMax");
        emit MorbinTimeDevPercentChanged(devMorbinTimePercent, newDevMorbinTimePercent);
        devMorbinTimePercent = newDevMorbinTimePercent;
    }




    function setMorbinTimeBuybackPercent(uint256 newBuybackMorbinTimePercent) external onlyOwner {
        require(newBuybackMorbinTimePercent <= buybackMorbinTimePercentMax, "Must be less than buybackMorbinTimePercentMax");
        require(newBuybackMorbinTimePercent >= buybackMorbinTimePercentMin, "Must be greater than buybackMorbinTimePercentMin");
        emit MorbinTimeBuybackPercentChanged(buybackMorbinTimePercent, newBuybackMorbinTimePercent);
        buybackMorbinTimePercent = newBuybackMorbinTimePercent;
    }


    function setJackpotMinAmount(uint256 newJackpotMinAmount) external onlyOwner {
        require(newJackpotMinAmount <= jackpotMinAmountMax, "Must be less than jackpotMinAmountMax");
        require(newJackpotMinAmount >= jackpotMinAmountMin, "Must be greater than jackpotMinAmountMin");
        emit JackpotMinAmountChanged(jackpotMinAmount, newJackpotMinAmount);
        jackpotMinAmount = newJackpotMinAmount;
    }


    function setJackpotMarketingAndDevPercent(uint256 newMarketingJackpotPercent, uint256 newDevJackpotPercent) external onlyOwner {
        require(newMarketingJackpotPercent <= marketingJackpotPercentMax, "Must be less than marketingJackpotPercentMax");
        emit JackpotMarketingPercentChanged(marketingJackpotPercent, newMarketingJackpotPercent);
        marketingJackpotPercent = newMarketingJackpotPercent;

        require(newDevJackpotPercent <= devJackpotPercentMax, "Must be less than devJackpotPercentMax");
        emit JackpotDevPercentChanged(devJackpotPercent, newDevJackpotPercent);
        devJackpotPercent = newDevJackpotPercent;
    }


    function setJackpotBuybackPercent(uint256 newBuybackJackpotPercent) external onlyOwner {
        require(newBuybackJackpotPercent <= buybackJackpotPercentMax, "Must be less than buybackJackpotPercentMax");
        require(newBuybackJackpotPercent >= buybackJackpotPercentMin, "Must be greater than buybackJackpotPercentMin");
        emit JackpotBuybackPercentChanged(buybackJackpotPercent, newBuybackJackpotPercent);
        buybackJackpotPercent = newBuybackJackpotPercent;
    }


    function setJackpotTimeToOccurAfterLastBuy(uint256 newTimeForJackpotToOccurAfterLastBuy) external onlyOwner {
        require(newTimeForJackpotToOccurAfterLastBuy <= timeForJackpotToOccurAfterLastBuyMax, "Must be less than timeForJackpotToOccurAfterLastBuyMax");
        require(newTimeForJackpotToOccurAfterLastBuy >= timeForJackpotToOccurAfterLastBuyMin, "Must be greater than timeForJackpotToOccurAfterLastBuyMin");
        emit JackpotTimeToOccurAfterLastBuyChanged(timeForJackpotToOccurAfterLastBuy, newTimeForJackpotToOccurAfterLastBuy);
        timeForJackpotToOccurAfterLastBuy = newTimeForJackpotToOccurAfterLastBuy;
    }


    function setJackpotMinBuyForLastBuy(uint256 newMinBuyAmountForJackpotLastBuy) external onlyOwner {
        require(newMinBuyAmountForJackpotLastBuy <= minBuyAmountForJackpotLastBuyMax, "Must be less than minBuyAmountForJackpotLastBuyMax");
        require(newMinBuyAmountForJackpotLastBuy >= minBuyAmountForJackpotLastBuyMin, "Must be greater than minBuyAmountForJackpotLastBuyMin");
        emit JackpotTimeToOccurAfterLastBuyChanged(timeForJackpotToOccurAfterLastBuy, newMinBuyAmountForJackpotLastBuy);
        minBuyAmountForJackpotLastBuy = newMinBuyAmountForJackpotLastBuy;
    }


    function enableOrDisableMorbinTimeOrJackpot(bool enableMorbinTime, bool enableJackpot) external onlyOwner {
        if(enableMorbinTime){
            emit MorbinTimeEnabled(true);
            isMorbinTimeEnabled = true;
        }
        else {
            emit MorbinTimeDisabled(false);
            isMorbinTimeEnabled = false;
        }

        if(enableJackpot){
            emit JackpotEnabled(true);
            isJackpotEnabled = true;
        }
        else {
            emit JackpotDisabled(false);
            isJackpotEnabled = false;
        }
    }










    // Vampire Functions

    // Path Functions for Router

    function getPathFromFtmToDollarPeg() public view returns (address[] memory) {
        address[] memory path = new address[](2);
        path[0] = spookySwapRouter.WETH();
        path[1] = dollarPegAddress;
        return path;
    }


    function getPathFromFtmToVamp() public view returns (address[] memory) {
        address[] memory path = new address[](2);
        path[0] = spookySwapRouter.WETH();
        path[1] = address(this);
        return path;
    }


    function getPathFromVampToFtm() public view returns (address[] memory) {
        address[] memory path = new address[](2);
        path[0] = address(this);
        path[1] = spookySwapRouter.WETH();
        return path;
    }



    // Price Functions

    function normalizeUsdcDecimals(uint256 amountsOut) public view returns (uint256){        
        if(dollarPegAddress == usdcAddress){
            amountsOut = amountsOut.mul(10**_decimals).div(10**usdcDecimals);
        }
        return amountsOut;
    }



    // VAMP Prices

    function getPriceOfOneVampInDollarValue() public view returns (uint256)  {
        uint256 amountOfFtmForOneVamp = spookySwapRouter.getAmountsOut((10**_decimals), getPathFromVampToFtm())[1];
        uint256 amountOfDollarForFtm = spookySwapRouter.getAmountsOut(amountOfFtmForOneVamp, getPathFromFtmToDollarPeg())[1];
        return normalizeUsdcDecimals(amountOfDollarForFtm);
    }

    function getPriceOfAmountVampWithDecimalsInDollarValue(uint256 vampAmount) public view returns (uint256)  {    
        uint256 amountOfFtmForVampAmount = spookySwapRouter.getAmountsOut(vampAmount.mul(10**_decimals), getPathFromVampToFtm())[1];
        uint256 amountOfDollarForFtm = spookySwapRouter.getAmountsOut(amountOfFtmForVampAmount, getPathFromFtmToDollarPeg())[1];
        return normalizeUsdcDecimals(amountOfDollarForFtm); 
    }

    function getPriceOfAmountVampInDollarValue(uint256 vampAmount) public view returns (uint256)  {
        uint256 amountOfFtmForVampAmount = spookySwapRouter.getAmountsOut(vampAmount, getPathFromVampToFtm())[1];
        uint256 amountOfDollarForFtm = spookySwapRouter.getAmountsOut(amountOfFtmForVampAmount, getPathFromFtmToDollarPeg())[1];
        return normalizeUsdcDecimals(amountOfDollarForFtm);  
    }


    // FTM Prices

    function getPriceOfOneFtmInDollarValue() public view returns (uint256)  {     
        uint256 amountOfDollarForOneFtm = spookySwapRouter.getAmountsOut((10**_decimals), getPathFromFtmToDollarPeg())[1];
        return normalizeUsdcDecimals(amountOfDollarForOneFtm);   
    }

    function getPriceOfAmountFtmWithDecimalsInDollarValue(uint256 ftmAmount) public view returns (uint256)  {     
        uint256 amountOfDollarForFtmAmount = spookySwapRouter.getAmountsOut((ftmAmount.mul(10**_decimals)), getPathFromFtmToDollarPeg())[1];
        return normalizeUsdcDecimals(amountOfDollarForFtmAmount);
    }

    function getPriceOfAmountFtmInDollarValue(uint256 ftmAmount) public view returns (uint256)  {
        uint256 amountOfDollarForFtmAmount = spookySwapRouter.getAmountsOut((ftmAmount), getPathFromFtmToDollarPeg())[1];
        return normalizeUsdcDecimals(amountOfDollarForFtmAmount);
    }




    // Time Functions For Jackpot

    function timeUntilJackpot() public view returns (uint256)  {
        if(block.timestamp > timeForJackpotToOccur){
            return 0;
        }
        return (timeForJackpotToOccur.sub(block.timestamp));
    }




    // Jackpot Fund Prices

    function jackpotFundAmountInDollarValue() public view returns (uint256)  {
        uint256 ftmAmountInContract = address(this).balance;
        if(ftmAmountInContract == 0){
            return 0;
        }
        return getPriceOfAmountFtmInDollarValue(ftmAmountInContract);
    }




    // Swap Functions

    function _swapFtmForVamp(uint256 ftmAmount) private {
        emit SwappedFtmForVamp(ftmAmount, spookySwapRouter.getAmountsOut(ftmAmount, getPathFromFtmToVamp())[1]);
        spookySwapRouter.swapExactETHForTokensSupportingFeeOnTransferTokens{value: ftmAmount}(0, getPathFromFtmToVamp(), 0x000000000000000000000000000000000000dEaD, block.timestamp.add(2 minutes));
    }


    function _swapVampForFtm(uint256 vampAmount) private {
        emit SwappedVampForFtm(vampAmount, spookySwapRouter.getAmountsOut(vampAmount, getPathFromVampToFtm())[1]);
        spookySwapRouter.swapExactTokensForETHSupportingFeeOnTransferTokens(vampAmount, 0, getPathFromVampToFtm(), address(this), block.timestamp.add(2 minutes));
    }











    // Process Functions

    function _processBuyBack() private {        // BuyBack From Jackpot and Morbin Time
        
        if(isTimeToProcessBuyBack){

            if(amountToBuybackAndBurnForJackpotOrMorbinTime > 0){

                isTimeToProcessBuyBack = false;

                uint256 vampBalanceOfDeadAddressBeforeBuyBack = balanceOf(0x000000000000000000000000000000000000dEaD);       // balance before BuyBack

                uint256 amountToSwap = amountToBuybackAndBurnForJackpotOrMorbinTime;
                amountToBuybackAndBurnForJackpotOrMorbinTime = 0;   // reentrancy
                _swapFtmForVamp(amountToSwap);

                uint256 vampBalanceOfDeadAddressAfterBuyBack = balanceOf(0x000000000000000000000000000000000000dEaD);    // balance after BuyBack

                uint256 addedVamp = vampBalanceOfDeadAddressAfterBuyBack.sub(vampBalanceOfDeadAddressBeforeBuyBack);    // sub balance after from before
                
                if(isBuyBackForJackpot){
                    totalJackpotVampAmountBoughtBackAndBurned = totalJackpotVampAmountBoughtBackAndBurned.add(addedVamp);   // add to the total
                    emit BuyBackForJackpot(addedVamp, totalJackpotVampAmountBoughtBackAndBurned, block.timestamp);
                }
                else{
                    totalMorbinTimeVampAmountBoughtBackAndBurned = totalMorbinTimeVampAmountBoughtBackAndBurned.add(addedVamp);   // add to the total
                    emit BuyBackForMorbinTime(addedVamp, totalMorbinTimeVampAmountBoughtBackAndBurned, block.timestamp);
                }

                emit JackpotFunded(address(this).balance, block.timestamp);
                
            }
        }
    }








    function _processMorbinTime() private {

        uint256 jackpotFundAmount = jackpotFundAmountInDollarValue();       // check balance of FTM in contract address

        if(jackpotFundAmount >= morbinTimeAmount){      // if higher than $100,000 

            if(!isTimeToProcessBuyBack){

                isMorbinOrJackpotin = true;

                // Morbin Time Percentages
                payable(marketingWallet).transfer((address(this).balance).mul(marketingMorbinTimePercent).div(100));     // 9% marketing
                payable(devWallet).transfer((address(this).balance).mul(devMorbinTimePercent).div(100));     // 1% dev

                uint256 amountToBuybackAndBurn = (address(this).balance).mul(buybackMorbinTimePercent).div(100);    // 70%
                amountToBuybackAndBurnForJackpotOrMorbinTime = amountToBuybackAndBurn;      // 70% used to buy back then burn VAMP, 20% left in jackpot  
                isTimeToProcessBuyBack = true;
                isBuyBackForJackpot = false;

                // Tracker Variables
                totalMorbinTimes = totalMorbinTimes.add(1);
                lastTimeMorbinTimeOccured = block.timestamp;
                totalMorbinTimeFtmAmountBoughtBackAndBurned = totalMorbinTimeFtmAmountBoughtBackAndBurned.add(amountToBuybackAndBurn);

                emit ItsMorbinTime(amountToBuybackAndBurn, totalMorbinTimes, totalMorbinTimeFtmAmountBoughtBackAndBurned, address(this).balance, jackpotFundAmountInDollarValue(), block.timestamp);
                
                // reset the last buyer and timestamp 
                lastBuyTimestamp = 0;
                lastBuyer = 0x000000000000000000000000000000000000dEaD;

            }
        }
    }




    










    function _processJackpot() private {

        uint256 jackpotFundAmount = jackpotFundAmountInDollarValue();       // check balance of FTM in contract address

        if(jackpotFundAmount >= jackpotMinAmount){   // if amount is over the minimum required amount, default is $1,000

            if(lastBuyTimestamp != 0){  // only check if timestamp isn't zero, //  if timestamp is zero it means no buy has occured yet

                if(block.timestamp > timeForJackpotToOccur) { // check time of last buy     // if current time is last buy + time, default 10 minutes after last buy

                    if(lastBuyer != 0x000000000000000000000000000000000000dEaD){    // check last buyer address, as long as it's not a dead address

                        if(!isTimeToProcessBuyBack){

                            isMorbinOrJackpotin = true;

                            // Transfer FTM
                            uint256 amountToAwardLastBuyer = (address(this).balance).mul(winnerJackpotPercent).div(100);      // Calculate how much the winner gets
                            payable(lastBuyer).transfer(amountToAwardLastBuyer);    // 50% winner
                            payable(marketingWallet).transfer((address(this).balance).mul(marketingJackpotPercent).div(100));     // 9% marketing
                            payable(devWallet).transfer((address(this).balance).mul(devJackpotPercent).div(100));     // 1% dev

                            uint256 amountToBuybackAndBurn = (address(this).balance).mul(buybackJackpotPercent).div(100);    // 10% default
                            amountToBuybackAndBurnForJackpotOrMorbinTime = amountToBuybackAndBurn;       // 10% used to buy back then burn VAMP, 30% left in jackpot 
                            isTimeToProcessBuyBack = true;
                            isBuyBackForJackpot = true;

                            // Tracker Variables
                            lastTimeJackpotOccured = block.timestamp;
                            lastJackpotAmountAwarded = amountToAwardLastBuyer;
                            lastJackpotWinner = lastBuyer;
                            totalJackpotTimes = totalJackpotTimes.add(1);
                            totalJackpotFtmAmountBoughtBackAndBurned = totalJackpotFtmAmountBoughtBackAndBurned.add(amountToBuybackAndBurn);
                            totalJackpotAmountAwarded = totalJackpotAmountAwarded.add(amountToAwardLastBuyer);
                            
                            emit JackpotAwarded(lastBuyer, amountToAwardLastBuyer, amountToBuybackAndBurn, totalJackpotTimes, totalJackpotAmountAwarded, getPriceOfAmountFtmInDollarValue(totalJackpotAmountAwarded),  
                                                totalJackpotFtmAmountBoughtBackAndBurned, address(this).balance, jackpotFundAmountInDollarValue(), block.timestamp);
                            
                            // reset the last buyer and timestamp 
                            lastBuyTimestamp = 0;
                            lastBuyer = 0x000000000000000000000000000000000000dEaD;


                        }
                    }
                }                          
            }
        }
    }





    
    



    function _processTaxSwap() private {

        _approve(address(this), spookySwapRouterAddress, balanceOf(address(this)));

        uint256 balanceOfContractBeforeSwap = address(this).balance;

        _swapVampForFtm(balanceOf(address(this)));      // swaps all the tokens in the contract, which will sell it for FTM

        uint256 balanceOfContractAfterSwap = address(this).balance;

        uint256 balanceToDisperse = balanceOfContractAfterSwap.sub(balanceOfContractBeforeSwap);

        uint256 tokensForJackpotToDisperse = tokensToSellForJackpot;
        tokensToSellForJackpot = 0;
        uint256 tokensForMarketingToDisperse = tokensToSellForMarketing;
        tokensToSellForMarketing = 0;
        uint256 tokensForDevToDisperse = tokensToSellForDev;
        tokensToSellForDev = 0;

        // Calculations for Percentages
        uint256 totalAmountOfTokens = tokensForJackpotToDisperse.add(tokensForMarketingToDisperse).add(tokensForDevToDisperse);
        uint256 percentOfMarketingFtm = tokensForMarketingToDisperse.mul(100).div(totalAmountOfTokens);
        uint256 percentOfDevFtm = tokensForDevToDisperse.mul(100).div(totalAmountOfTokens);

        // Calculate how much FTM to transfer
        uint256 ftmAmountInContractToDisperse = balanceToDisperse;
        uint256 marketingFtm = ftmAmountInContractToDisperse.mul(percentOfMarketingFtm).div(100);
        uint256 devFtm = ftmAmountInContractToDisperse.mul(percentOfDevFtm).div(100);

        // Transfer FTM
        payable(marketingWallet).transfer(marketingFtm);    
        payable(devWallet).transfer(devFtm);

    }















    function _processTaxes(address sender, uint256 amount, uint256 totalTaxPercent, uint256 jackPotTaxPercent, uint256 marketingTaxPercent, uint256 devTaxPercent) private {
        
        uint256 totalTaxAmount = amount.mul(totalTaxPercent).div(100);

        if(totalTaxAmount > 0){    

            uint256 jackpotTaxAmount = amount.mul(jackPotTaxPercent).div(100);
            uint256 marketingWalletTaxAmount = amount.mul(marketingTaxPercent).div(100);
            uint256 devWalletTaxAmount = amount.mul(devTaxPercent).div(100);
            
            _balances[address(this)] += totalTaxAmount;        // transfer in taxes to VAMP Contract for sell
            emit Transfer(sender, address(this), totalTaxAmount);

            tokensToSellForJackpot += jackpotTaxAmount;
            tokensToSellForMarketing += marketingWalletTaxAmount;
            tokensToSellForDev += devWalletTaxAmount;
        }
    }






















    function _processBuy(address sender, address receiver, uint256 amount, uint256 senderBalance, bool takeFee) private {

        if(isJackpotEnabled && !isMorbinOrJackpotin){      // make sure we aren't handling other functions first

            uint256 amountFtmFromVamp = spookySwapRouter.getAmountsOut(amount, getPathFromVampToFtm())[1];      // go from VAMP to FTM
            uint256 priceOfVampBoughtInDollarValue = getPriceOfAmountFtmInDollarValue(amountFtmFromVamp);      // FTM dollar value

            if(priceOfVampBoughtInDollarValue >= minBuyAmountForJackpotLastBuy){           // check dollar value of buy, if more than $10
                if(!isContractByHash(receiver) && !isContractBySize(receiver)){
                    lastBuyTimestamp = block.timestamp;
                    lastBuyer = payable(receiver);
                    timeForJackpotToOccur = lastBuyTimestamp.add(timeForJackpotToOccurAfterLastBuy);
                    emit JackpotTimeExtended(lastBuyer, lastBuyTimestamp, address(this).balance, jackpotFundAmountInDollarValue(), timeForJackpotToOccur);
                }
            }
        }

        // Transfer Specific
        _balances[sender] = senderBalance.sub(amount);     // transfer out
        uint256 receiverAmount = amount;
        if(takeFee){
            receiverAmount = amount.sub(amount.mul(totalBuyTax()).div(100));
        }
        _balances[receiver] += receiverAmount;       // transfer in
        emit Transfer(sender, receiver, receiverAmount);
        emit BoughtVAMP(receiver, receiverAmount, block.timestamp);

    }













    function _processSell(address sender, address receiver, uint256 amount, uint256 senderBalance, bool takeFee) private {
        
        // Transfer Specific
        _balances[sender] = senderBalance.sub(amount);     // transfer out
        uint256 receiverAmount = amount;
        if(takeFee){
            receiverAmount = amount.sub(amount.mul(totalSellTax()).div(100));
        }
        _balances[receiver] += receiverAmount;       // transfer in
        emit Transfer(sender, receiver, receiverAmount);
        emit SoldVAMP(sender, receiverAmount, block.timestamp);

    }



















    function _processNormalTransfer(address sender, address receiver, uint256 amount, uint256 senderBalance, bool takeFee) private {

        // Transfer Specific
        _balances[sender] = senderBalance.sub(amount);     // transfer out
        uint256 receiverAmount = amount;
        if(takeFee){
            receiverAmount = amount.sub(amount.mul(totalTransferTax()).div(100));
        }
        _balances[receiver] += receiverAmount;       // transfer in
        emit Transfer(sender, receiver, receiverAmount);

    }


   


    
















    function _transfer(address sender, address receiver, uint256 amount) internal virtual {
        require(sender != address(0), "ERC20: transfer from the zero address");
        require(receiver != address(0), "ERC20: transfer to the zero address");
        require(amount > 0, "Transfer amount must be greater than zero");

        // reentrancy
        uint256 senderBalance = _balances[sender];
        _balances[sender] = 0;      // sets the balance to 0 temporarily, at the end it is recalculated correctly. 

        require(senderBalance >= amount, "ERC20: transfer amount exceeds balance");


        if(!isExcludedFromMaxWalletSize[receiver]){
            uint256 receiverBalance = _balances[receiver].add(amount);
            require(receiverBalance <= maxWalletSize, "Must not go over max wallet size.");
        }
  

        if(!isAllowedToProvideLiquidity[sender] && !isAllowedToProvideLiquidity[receiver] ){   
            if(sender == spookySwapPairAddress || receiver == spookySwapPairAddress){      // allows transfers, but not trading
                require(isTradingOpen, "Trading is Not Open");          // isTradingOpen is set to true to open trading, can never be set to false to stop trades
            }
        }



    
        // Morbin Time
        if(isMorbinTimeEnabled && !isMorbinOrJackpotin){
            _processMorbinTime();
        }
        

        // Jackpot
        if(isJackpotEnabled && !isMorbinOrJackpotin){
            _processJackpot();
        }
        

        // Process BuyBack
        if(!(spookySwapPairAddress == sender)){       // if this is not a buy, then we need to process the buyback
            if(!isInProcessTaxSwap){
                isInProcessTaxSwap = true;
                _processBuyBack();
                isInProcessTaxSwap = false;
            }
        }



        // Taxes
        bool takeFee = true;
        if(isExcludedFromFee[sender] || isExcludedFromFee[receiver]){
            takeFee = false;
        }



    
        // Process Taxes
        if(!(spookySwapPairAddress == sender)){       // if this is not a buy, then we need to process the tax tokens
            if(balanceOf(address(this)) >= minimumVampAmountToSwap){        // the minimum is 100 VAMP
                if(!isInProcessTaxSwap){
                    isInProcessTaxSwap = true;
                    _processTaxSwap();
                    isInProcessTaxSwap = false;
                }
            }
        }


        // Tax Collection
        uint256 totalTaxPercent = 0;
        uint256 jackPotTaxPercent = 0;
        uint256 marketingTaxPercent = 0;
        uint256 devTaxPercent = 0;
   

        if(spookySwapPairAddress != receiver && spookySwapPairAddress != sender){     // Normal Transfer
            _processNormalTransfer(sender, receiver, amount, senderBalance, takeFee);
            totalTaxPercent = totalTransferTax();
            jackPotTaxPercent = jackpotTaxOnTransfersPercent;
            marketingTaxPercent = marketingTaxOnTransfersPercent;
            devTaxPercent = devTaxOnTransfersPercent;
        }


        if(spookySwapPairAddress == sender){       // Buy
            _processBuy(sender, receiver, amount, senderBalance, takeFee);
            totalTaxPercent = totalBuyTax();
            jackPotTaxPercent = jackpotTaxOnBuysPercent;
            marketingTaxPercent = marketingTaxOnBuysPercent;
            devTaxPercent = devTaxOnBuysPercent;
        }


        if(spookySwapPairAddress == receiver){     // Sell
            _processSell(sender, receiver, amount, senderBalance, takeFee);
            totalTaxPercent = totalSellTax();
            jackPotTaxPercent = jackpotTaxOnSellsPercent;
            marketingTaxPercent = marketingTaxOnSellsPercent;
            devTaxPercent = devTaxOnSellsPercent;
        }



        // Take The Taxes
        if(takeFee){
            _processTaxes(sender, amount, totalTaxPercent, jackPotTaxPercent, marketingTaxPercent, devTaxPercent);
        }


        isMorbinOrJackpotin = false;

    }



    function isContractByHash(address account) public view returns (bool) {   
        bytes32 hash;
        assembly {hash := extcodehash(account)}
        return ((hash != 0x0) && (hash != 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470));
    }


    function isContractBySize(address account) public view returns (bool) {
        uint256 size;
        assembly { size := extcodesize(account) }
        return (size > 0);
    }










}
